= Guide to Using Git
:author: HonkingGoose
:revnumber: 0.0.7
:revdate: 22.10.2019
:toc: right
:toclevels: 2
:icons: font
:sectnums:

[preface]
== Preface

This is a guide on how to use git, while working in a small team of collaborators.

=== License

This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/3.0.

=== Acknowledgements

This work is heavily inspired by the Pro Git book.
Thanks to all the collaborators at the Pro Git book project, for making this guide possible.

=== Conventions

A `$` sign denotes Linux terminal input.

== Git basics

=== Why use git?

Basically, you use git to keep a history of changes.
This way you can revert any changes that turn out to be bad or not wanted.
You can use git to keep your work on separate branches, so that you can keep our in-development work seperate from production code.

=== What is git?

==== Snapshots not differences

Git makes a "photo" or snapshot, of the state of the repository when you commit.

==== Nearly every operation is local

Nearly everything you do in git is local.
This is why git operations are very fast, there is no need to pull data from a remote server.
You cannot fetch/pull or push if you are offline.

TIP: Changes will only be visible to others after you've pushed them to the remote (usually called `origin` or `upstream`).

==== Git has integrity

Everything in Git is checksummed before it is saved and is then referred to by that checksum.
This means it’s impossible to change the contents of any file or directory without Git knowing about it.
Git stores everything in its database not by file name but by the hash value of its contents.

Git uses a SHA-1 hash algorithm for checksumming.
This is a 40-character string calculated on the contents of a file or directory structure in Git.
A SHA-1 hash looks something like this:

[source, console]
----
c44480f344b651b283b31350dc166f9e41331bf5
----

==== Git generally only adds data

When you do actions in Git, nearly all of them only *add* data to the Git database.
It is hard to get git to do anything that is not undoable or to make it erase data in any way.
You can however lose or mess up changes that you haven’t committed.
After you commit a snapshot into Git, it is very difficult to lose, especially if you regularly `git push` your database to another repository.

WARNING: This also means that password/token leakage via git is hard to undo.
Consider a leaked password/token compromised, and change them immediately!

==== The three states of a file in git

TIP: Be sure to read this section for a full understanding of git.

Git has three main states that your files can reside in: *modified*, *staged*, and *committed*:

* Modified means that you have changed the file but have not committed it to your database yet.
* Staged means that you have marked a modified file in its current version to go into your next commit snapshot. (`git add`)
* Committed means that the data is safely stored in your local database. (`git commit`)

==== Git lifecycle

The main lifecycle of a file is:

1. A file starts life as being _untracked_.
_Untracked_ files are not saved by git.
2. To save a file, you need to tell git to start tracking it.
Add the file to the _staging area_ with `git add`.
3. The file is now *staged*.
4. From the _staging area_ commit the file with `git commit`. The file is now *committed*.
5. If you edit the file, git will know about this, and the file will be *modified*.
6. You will need to stage and commit the file, to go to the state *committed* again.

You can use the `git status` command to get a full overview of where your files are in the git lifecycle.

See the picture below for a graphical representation of the above section.

.git lifecycle
image::https://git-scm.com/book/en/v2/images/lifecycle.png[Git lifecycle]

=== Git status

If you're ever unsure of what the status of your repository is, use `git status` to see:

* What branch you are on.
* What the status of the current working directory is (files added, changed, removed/moved).
* What git is currently working on, like merge conflict resolution, rebase operation or something else.

Usually `git status` also gives advice on how to do certain things.
Be sure to use `git status` if you're stuck.

TIP: Git status will only be up-to-date after fetching with `git fetch --all`.

== Getting up to date with changes

=== git fetch

Use `git fetch --all` to see if there are any changes.
Git keeps you up to date on changes:

[source, console]
----
$ git fetch --all
remote: Enumerating objects: 10, done.
remote: Counting objects: 100% (10/10), done.
remote: Compressing objects: 100% (6/6), done.
remote: Total 10 (delta 2), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (10/10), done.
From https://github.com/<repository_name>
   b0df5a5..636e48a  git_documentation -> origin/git_documentation
 * [new branch]      develop    -> origin/develop
 * [new branch]      hotfix     -> origin/hotfix
----

Git tells us:

* I got new commits from <repository_name>.
* The branch git_documentation has moved from commit b0df5a5 to 636e48a.
* The changes to branch git_documentation are coming from origin/git_documentation.
* There are two new branches, develop and hotfix.

Then if I go to my own branch, (on which I did some remote work).
I see the following message:

[source, console]
----
$ git checkout git_documentation
Switched to branch 'git_documentation'
Your branch is behind 'origin/git_documentation' by 2 commits, and can be fast-forwarded.
  (use "git pull" to update your local branch)
----

Git has noticed that upstream has changed, and even gives help on how to get up to date: "use "git pull" to update your local branch".

== Viewing the commit history (git log)

To view the commit history use `git log`.
The standard output of the `git log` command is the commit history, where each commit has a commit number, author, date and commit message.
The most recent commits are on top.
You can alter the output of `git log` using options, I will list a few useful ones in the section on useful `git log` options.

=== One log to rule them all

I find that one of the most useful git log options is:
`git log --all --decorate --oneline --graph`.

You can remember this by "A dog".

== Useful git log options

=== all

`git log --all` shows all branches, even ones that have not been merged.
It also shows stashes made via `git stash`.

This command is bit overkill if all you're interested in is the local history, but if you want a full overview of the repository's history, use `--all`.

=== oneline

Use `git log --oneline` to shorten the default output from git log, to a short SHA-1 checksum, and commit message.

=== patch

Use `git log -p` or `git log --patch` to view the difference(s) in the code between each commit.

=== decorate

Use `git log --decorate` to show which branch(es) and tag(s) are associated with each commit.
This is useful to get a overview of the current status of your branch.

=== author

If you only want to see commits made by a specific author, you use `git log --author=<pattern>`.

The `<pattern>` is a regular expression.
You only need to enter enough letters to have a unique match.

TIP: The regular expression is case sensitive.

[source, console]
----
$ git log --author=Honk
commit 863336a23edd5a88c83480d0a9486265a20a2a52
Author: HonkingGoose <34918129+HonkingGoose@users.noreply.github.com>
Date:   Wed Oct 9 16:01:25 2019 +0200

    Create section on branch management

    Change headers so that there is a clear hierarchy
----

=== graph

The graph option gives you a visual overview of the branches that have been merged.

=== no-merges

Use `git log --no-merges` to exclude merge commits.

=== since

Say you want to see what changes were made today.
You can use `$ git log --since="midnight"`.

The `--since` option also accepts input like: "yesterday", "1 week ago", "2 days ago".
You can also enter a date: `git log  --since="<year>-<month>-<day>"`

== Making changes to the repository

Read https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository[chapter 2.2] of the Pro Git book.

== Git branches

=== Why have branches at all?

You can use a branch to keep your work seperate from the main line of development.
This has multiple benefits:

1. You can work in isolation on your own work.
2. You can use multiple branches to try multiple approaches, when you finally arrive at the perfect solution, you can merge that branch back into the development branch.

When you are done with your work, you can merge your working branch back into the development branch.

NOTE: The `master` branch in Git is not a special branch. It is exactly like any other branch. The only reason nearly every repository has one is that the `git init` command creates it by default and most people don’t bother to change it.

=== Git branches in a nutshell

Read https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell[chapter 3.1] of the Pro Git book.

=== Basic branch workflow

Read https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging[chapter 3.2] of the Pro Git book.

TIP: You can remove a branch after you've merged, the command for this is `git branch -d <branch_name>`.
Git will warn you if you try to remove a branch you have not merged yet.

=== Branch management

Read https://git-scm.com/book/en/v2/Git-Branching-Branch-Management[chapter 3.3] of the Pro Git book.

== Working with remotes

=== Basics

Usually you share your work via a git server.
This can be done by setting up a git server, either locally on a NAS, or by using a service like GitHub or GitLab.
This server is called a remote.

For more on working with remotes: https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes

In most cases you don't work with the remotes themselves directly, but use remote-tracking branches.

=== Remote-tracking branches

Remote-tracking branches are references to the state of remote branches.
Think of them as bookmarks, to remind you where the branches in your remote repositories were the last time you connected to them.

Remote-tracking branch names take the form <remote>/<branch>.
If you wanted to see what the `master` branch on the remote `origin` looked like, as of the last time you communicated with it, you would check the `origin/master` branch.

NOTE: The remote name `origin` has no special meaning in git.
`origin` is just the default name for a remote when you run `git clone`.

=== Using remote-tracking branches

==== Run git fetch first

First get up-to-date on the changes on the remote branch, by running a `git fetch --all` command.

==== Pushing

When you want to share your work, you run `git push <remote> <branch>`.

CAUTION: If you're on a branch and just issue `git push` git will push that branch, so be sure you are on the correct branch if you don't specify a branch name to the `git push` command.

==== Checkout

Checking out a local branch from a remote-tracking branch automatically creates what is called a “tracking branch”.
Tracking branches are local branches that have a direct relationship to a remote branch.

You can checkout the remote branch by running:
`git checkout <remote_branch_name>`.

If the branch name you checkout does not exist yet, **and** exactly matches a name on only one remote, git will create a tracking branch for you.

Sometimes you will need to create a tracking branch manually:
`git checkout --track <remote_name>/<branch_name>`.

==== View information about tracking branches

Use `git branch -vv` to see what tracking branches you have.

==== Deleting a remote branch

When you and your collaborators are done with a remote branch, and the changes have been merged into `master`, you can delete that branch.

`git push <remote_name> --delete <branch_name>`

WARNING: Do not delete branches that others are still working on!

==== Further reading on remote branches

https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches

== Git checkout

=== Basics

Git only keeps a record of files you've committed. (`git add` and then `git commit`).
If you do not commit, git will forget about the changes you made when you checkout another branch with `git checkout`.

=== Checkout while working directory not clean

WARNING: If the working directory is not clean (which means you have not committed all work), and you force a `git checkout` you **will lose work**!

Git will not let you switch branches if the working directory is not clean. See the example below:

[source,console]
----
$ git status
On branch git_documentation
Your branch is up-to-date with 'origin/git_documentation'.
Changes not staged for commit:
	modified:   <file_name>

$ git checkout master
error: Your local changes to the following files would be overwritten by checkout:
	<file_name>
Please, commit your changes or stash them before you can switch branches.
Aborting
----

Git also offers help on how to proceed: "Please, commit your changes or stash them before you can switch branches."
The easy way is to commit your work, then checkout the other branch.

Advanced users of git can also use `git stash`, then checkout, and when returning do `git apply` to get their work back.
For more on stashing and applying see: https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning[Stashing and Cleaning] from the Pro Git book.

== Git recipe-book

=== Initial repository setup

==== Setting up a git repository before starting work

First create a directory that will be the root of your project.
You can create a directory with the `mkdir` command on Linux.

[source, console]
----
$ mkdir ~/Documents/repo/project_name
$ cd ~/Documents/repo/project_name
$ git init
Initialized empty Git repository in /home/user_name/Documents/repo/project_name/.git/
----

Now you can start creating files, and then start tracking them with `git add` and `git commit`.

It's a good idea to set up a `.gitignore` file in the root of the directory.
Git will ignore the files and folders listed in the `.gitignore` file.

==== Setting up a git repository after you've started working

You have already started working, and now want to use git to track your files.
It's usually a better idea to setup a repo before you start adding files to your project, but you can always start tracking files with git.
Here's how:

1. You have a directory with files, let's suppose it's at `~/Documents/repo/project`.
2. Go to the directory with `$ cd ~/Documents/repo/project`
3. Initialize a new git repository with `$ git init`.
4. It's a good idea to make a `.gitignore` file, so that you don't commit unwanted stuff.
5. Since the directory already contains files, you want to start tracking them with `git add` and `git commit`.

=== Ignore certain files/directories

==== Basics

You usually don't want to commit files like packages, temporary files, log files and such to the repository.

You can tell git what files/folders to ignore by putting a .gitignore file in the root of the repository.
Git will read the .gitignore file before doing anything.

Each line in the .gitignore file specifies a pattern.
On a pattern match, git will ignore that file/directory.

TIP: The .gitignore file must be called .gitignore and be placed in the root of the repository to work.

TIP: Do commit the .gitignore file itself.

==== Creating a new repo using GitHub

1. Go to the new repository page on GitHub.
2. Click on the "add .gitignore" dropdown.
3. Select the correct file from the dropdown. (For Node projects, select `Node`)
4. Clone the repository to your own computer.

==== Where to find a good .gitignore file

You can find good .gitignore files here:
https://github.com/github/gitignore

==== Editing a gitignore file

See https://git-scm.com/docs/gitignore for a guide on editing a gitignore file.

==== Adding a .gitignore file after you've started work

You can always add a .gitignore file to the root of your project, even after you've started work.

CAUTION: You will still need to remove the now ignored files from the repository.
Use the `git rm` command to remove the file(s).
Then add and commit the removal.

=== Branch management

==== Update a branch

===== Using git pull

CAUTION: Be sure you are on the correct branch before pulling!

[source,console]
----
$ git checkout <branch_to_update>
$ git fetch --all
$ git pull
----

NOTE: `git pull` is shorthand for: `git fetch`, `git merge origin<branch_you're_on> <branch_you're_on>`.

===== Manually

[source, console]
----
$ git fetch --all
$ git merge origin/<branch_to_update> <branch_to_update>
----

==== Add new files/changes

[source,console]
----
$ git add
$ git commit -v
----

Make a commit message. Follow the section on  https://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project[commit guidelines] from the Pro Git book.

==== Setup a new branch

Setting up (and switching to) a new branch is a very common operation.
That's why the `git checkout` command has a option to make (and switch) to a new branch.

===== Formal way

The formal way to setup a new branch is:

[source, console]
----
$ git branch formal_branch_switch
$ git checkout formal_branch_switch
----

===== Fast way

The fast way to make, and switch to a new branch:

[source, console]
----
$ git checkout -b fast_branch_switch
----

==== Push changes on a known branch

[source, console]
----
$ git push
----

==== Push changes on a new branch

If you try to push changes on a branch that is not yet on the remote (`origin`), you will need to specify that the `origin` branch will be upstream.

The command is:

[source, console]
----
$ git push --set-upstream origin <branch_name>
----

==== Check which branches are/not merged

*Merged:*
Use `git branch --merged <branch_name>`.
This shows which branches have been merged into the `<branch_name>``.

*Not merged:*
Use `git branch --no-merged	<branch_name>`.
It shows all local branches, that have not been merged into `<branch_name>`.

If you don't specify a branch name the current branch will be used for the comparison.

== GitFlow

=== Warnings and tips

==== Know what branch you are working on

CAUTION: It is vitally important that you know on what branch you are working!

TIP: Use `git status` before adding, committing, pulling or pushing!

==== Tips for committing

* Commit early and commit often.
* Code that depends on other code should be committed in one commit.
* You can always clean up commits on your own personal branch(es) after you are done working trough the use of `git rebase`.

===== Commit messages

* Commit messages start with a capital letter.
* Commit messages don't end with a `.`
* Commit messages are 50 characters or less.
* Use language like "Fix bug" not "Fixed bug" (git talks to you in this style too)

====== Example of a good commit message

[source, console]
----
Add section on git commit message
----

=== Basics of GitFlow

We will be using the GitFlow workflow.
There are three main branches, `master`, `develop`, `hotfix`.
Stable, tested code goes into `master`.
Normal development work goes into `develop`.
Hotfixes go into the `hotfix` branch, and are merged into `master` when the hotfix is ready for release.

The branch name `origin` means GitHub.

==== Progress of code trough GitFlow

Work moves from the developer's personal branches to the `develop` branch to the `master` branch.

Like this:

`feature_1` -> `develop` -> `master`

This means that only stable and tested code goes into master.
`master` is always a potentially releaseable increment of work.

=== Preconditions

You have cloned the repository with `git clone`.
You have told git your username and email.
You have commit rights for the `master`, `develop` and `hotfix` branches.

=== Starting work for the team

You want to work on a new piece of code, let's say a PUT request for a table.

==== Checkout develop branch and pull

You first checkout the `develop` branch, and pull any changes:

[source, console]
----
$ git checkout develop
$ git pull
----

==== Make personal branch for feature from dev branch

TIP: First pull new changes, to ensure you are at the tip of development.

TIP: Make sure you are branching from `develop`!

[source, console]
----
$ git checkout -b PUT_request_invoice
----

==== Work on personal branch

You work on the feature, and make commit(s).
You push your branch to GitHub with `git push set-upstream origin/<branch_name>`.
This tells git to set the upstream for this branch at origin (usually GitHub).

NOTE: `origin` is a git remote, which is hosted at GitHub.

[source, console]
----
$ git add api.js
$ git commit -m "Add PUT request for invoice"
$ git push origing
$ git push set-upstream origin PUT_request_invoice
----

==== Merging personal work into dev

You have finished working on the feature, and it is ready to be merged into `develop`.
You start by checking on which branch you are.
Then you checkout the `develop` branch.
You pull the `develop` branch to ensure you have the latests commits.
Then you merge your own work into the `develop` branch.

[source, console]
----
$ git status
On branch PUT_request_invoice
$ git checkout develop
$ git pull
$ git merge PUT_request_invoice
----

==== Making a release to master from develop

When the work on `develop` has been tested, and is ready for production, that work is merged into the `master` branch.

[source, console]
----
$ git checkout master
$ git pull
$ git merge develop
----

== Cleaning up your work before merging

=== Why you should clean up your personal history

Suppose you are working on a feature on your own branch.
You have finished work and now have a history of commits like:

[source, console]
----
e7472d7 Add newline
7c5e47f Add missing backtick
e8e4873 Fix capitalization
ad7a782 Finally really fix bug, hallelujah
af4363d Fix bug
9c4469f Fix bug
----

Merging all those commits will only add noise to the history of the project.
You can squash those commits into a single commit by rebasing.
This will lead to a cleaner history.

=== Important warnings on changing history

WARNING: Do not change the history of public, shared or stable branches.
This warning applies to branches such as: `master`, `develop` and `hotfix`.

=== Tools to change history on personal branches

==== Git rebase

Git rebase is very useful to clean up cruft.
That said, do not use `git rebase` unless you know what you are doing!
I strongly recommend following the guide at https://git-rebase.io/[git-rebase.io].

==== Git push --force

After you're done changing the history on a personal branch via `git rebase`, you can then force push that history, to your remote branch at `origin`.

WARNING: Do not force push (`git push -f` or `git push --force`) your changes to branches like `master`, `develop` and `hotfix`.

== Further reading

* https://git-scm.com/book[Pro Git] book, read chapters 1, 2 and 3.
* https://git-scm.com/docs/giteveryday A useful minimum set of commands for Everyday Git
* https://github.github.com/training-kit/ You can find a git cheat sheet here.
* https://git-rebase.io/[git-rebase.io] website about `git rebase`.
* https://www.atlassian.com/git/tutorials/using-branches/merge-conflicts[atlassian.com] Learn how to resolve merge conflics.
